# Динамические структуры данных

Итак, мои юные постигатели компьютерных наук, мы уже более менее настроились на работу, вникли в суть происходящего, теперь можно начинать делать что-то похожее на программирование. Как многие из вас знают, на статических структурах данных далеко не уедешь - поэтому тема данной лабораторной работы - динамические структуры данных!

# Односвязный список
Итак, рассмотрим задачу.   
Допустим, мы хотим создать некое приложение для работы с графикой.  
Конечно, на си мы никакое приложение для работы с графикой не осилим. Всё же "слона надо кушать по котлеткам".  

P.S.
Я это пишу не в прикол, попробуйте сделать какую-нибудь задачку из головы, без гпт. И вы поймёте что такое "понять на кончиках пальцев".  
Ну или можете выбрать делать всё по жизни тяп-ляп, на ваше усмотрение.

#### Моделирование предметной области
У нас есть несколько сущностей - Точка, Кривая.  
Точка - структура хранящая в себе x и y (координаты в декартовой системе)  
Кривая - некий набор точек идущих друг за другом  

Создадим структуру для описания точки:  
```c
struct Point {
    int x; // целочисленная переменная x
    int y;
}
```

Для описания кривой, нужно чуть более комплексно осмыслить понятие "кривой линии". Кривая - это массив упорядоченных точек (от начальной к конечной). Мы можем добавить точку в нашу кривую, или удалять точки "одна за другой". 

**Но именно как структура данных - односвязный список, это по сути некий узел, содержащий  информационное поле (поля), и указатель на следующий элемент!**

```c
struct LinkedList {
    struct Point data; // информационное поле
    LinkedList *link; // указатель на следующий элемент
}
```

В конечном итоге, наш файл `draw.h` будет похож на что-то вроде  
```c
struct Point {
    int x; 
    int y;
};

struct LinkedList {
    struct Point data;
    struct LinkedList *next;
};
```

В целом, на этом моделирование предметной области закончено, мы создали основные структуры данных. Давайте немного поиграемся с ними.  
Создадим файл `draw_test.c`.
1. Создадим точку и попробуем обратиться к её атрибутам
```c
#include <stdio.h>
#include "draw.h"

int main() {  
    printf("Start example of creation point: \n");
    struct Point p;
    p.x = 13;
    p.y = 24;
    printf("x=%d, y=%d \n", p.x, p.y);
    printf("Point created: \n\n");
}
```

Окей, теперь мы понимаем как можно организовывать простые типы данных в структуры
2. Создадим список и добавим созданную точку в список, обратимся к тем же атрибутам
```c
#include <stdio.h>
#include "draw.h"

int main() {  
    printf("Start example of creation point: \n");
    struct Point p;
    p.x = 13;
    p.y = 24;
    printf("x=%d, y=%d \n", p.x, p.y);
    printf("Point created: \n\n");
    

    printf("Creating simple list \n");
    struct LinkedList list;
    list.data = p;
    printf("My first point: x=%d, y=%d\n", list.data.x, list.data.y);
    printf("List first element created \n");    
}
```

3. Добавим новый узел и обратимся к его атрибутам и получим его координаты  
```c
#include <stdio.h>
#include "draw.h"

int main() {  
    printf("Start example of creation point: \n");
    struct Point p;
    p.x = 13;
    p.y = 24;
    printf("x=%d, y=%d \n", p.x, p.y);
    printf("Point created: \n\n");
    

    printf("Creating simple list \n");
    struct LinkedList list;
    list.data = p;
    printf("My first point: x=%d, y=%d\n", list.data.x, list.data.y);
    printf("List first element created \n");
    
    struct LinkedList second_node;
    elemT second_point;
    second_point.x = 15;
    second_point.y = 26;
    second_node.data = second_point;
    list.next = &second_node;

    printf("Get all points \n");
    printf("My second point: x=%d, y=%d\n", list.next->data.x, list.next->data.y);
}
```

Итак, что мы видим?  
Что в целом, у нас есть некая модель данных и некая динамическая структура данных. Но с этим невозможно работать, крайне долго создавать всё это, неудобно читать код так как видно слишком много деталей реализации. Хочется немного абстрагироваться.

Посмотрим код внимательно и поймём как его можно организовать:
```c
#include <stdio.h>
#include "draw.h"

int main() {  
    printf("Start example of creation point: \n"); 
    struct Point p;  
    p.x = 13;  // мусор, хочу функцию которая бы сама создавала мне Point (поздравляю, вы прочувствовали что такое "конструктор")
    p.y = 24; // так кстати в лабах нельзя делать, прямое нарушение стайлгайда https://github.com/algo-2025/.github/blob/main/profile/do-donts.md
    printf("x=%d, y=%d \n", p.x, p.y); 
    printf("Point created: \n\n");
    

    printf("Creating simple list \n");
    struct LinkedList list; // мусор, хочу функцию которая бы мне создавала структуру и сама выделяла память
    list.data = p; 
    printf("My first point: x=%d, y=%d\n", list.data.x, list.data.y);
    printf("List first element created \n");
    
    struct LinkedList second_node; // самый мусорный мусор, хочу чтобы добавлять элементы было легко
    elemT second_point;
    second_point.x = 15;
    second_point.y = 26;
    second_node.data = second_point;
    list.next = &second_node;

    printf("Get all points \n");
    printf("My second point: x=%d, y=%d\n", list.next->data.x, list.next->data.y);
}
```

Отлично, а теперь начнём с простого, создадим что-то вроде конструктора для нашей точки. Функция будет принимать два аргумента - x и y (координаты), а возвращать будет точку.  

```c
struct Point createPoint(int x, int y) {
    struct Point p;

    p.x = x;
    p.y = y;

    return p;
}
```

Далее сделаем то же самое для нашего списка:  

```c
struct LinkedList* newList(struct Point data) {
    struct LinkedList *node = (struct LinkedList*) malloc(sizeof(struct LinkedList)); // тут я надеюсь вам на лекции рассказали

    if (!node) {
        printf("Memory allocation failed!\n");
        exit(EXIT_FAILURE);
    }

    node->data = data;
    node->next = NULL; // башка должна указывать на NULL-pointer, чтобы мы в циклах допустим могли итерироваться пока node->next != NULL

    return node;
}
```
Дальше, добавим возможность удобненько добавить точку к нам в список  

```c
void appendItem(struct LinkedList *head, struct Point data) { 
    struct LinkedList *current = head;

    while (current->next != NULL) { // можно улучшить, сохранив ссылку на последний элемент в структуру
        current = current->next;
    }

    current->next = newList(data); // подумайте
}
```

Ну и конечно же, за собой память надо чистить!  
```c
void freeList(struct LinkedList *head) {
    struct LinkedList *current = head;

    while (current != NULL) {
        struct LinkedList *next = current->next;
        free(current);
        current = next;
    }
}
```

По итогу, наш пример преобразился в:  
```c
#include "draw.h"

int main() {  
    printf("Start example of creation point:\n");
    struct Point p = createPoint(13, 24);
    printf("x=%d, y=%d\n\n", p.x, p.y);

    printf("Creating simple list\n");
    struct LinkedList *list = newList(p);

    appendItem(list, createPoint(15, 26));
    appendItem(list, createPoint(17, 30));

    printf("List points:\n");
    struct LinkedList *current = list;

    int i = 1;
    while (current != NULL) {
        printf("Point %d: x=%d, y=%d\n", i++, current->data.x, current->data.y);
        current = current->next;
    }

    freeList(list);
    printf("\nAll memory freed.\n");
    return 0;
}
```

И мы можем делать так сколь угодно долго. 
Например я невзначай подсунул здесь симпатичную печать списка, можно это также вынести. Например:  


```c
void printList(struct LinkedList *head) {
    struct LinkedList *current = head;

    int i = 1;
    while (current != NULL) {
        printf("Point %d: x=%d, y=%d\n", i++, current->data.x, current->data.y);
        current = current->next;
    }
}
```

```c
#include "draw.h"

int main() {  
    printf("Start example of creation point:\n");
    struct Point p = createPoint(13, 24);
    printf("x=%d, y=%d\n\n", p.x, p.y);

    printf("Creating simple list\n");
    struct LinkedList *list = newList(p);

    appendItem(list, createPoint(15, 26));
    appendItem(list, createPoint(17, 30));

    printf("List points:\n"); 
    printList(list);
    freeList(list);
    printf("\nAll memory freed.\n");
    return 0;
}
```

Итак, с этим уже можно работать!  
У нас есть смоделированная предметная область, созданы структуры данных и функции для организации работы с ними. 
Далее мы можем например **посчитать сколько точек в кривой**:

```c
struct LinkedList *current = list; // для тех кто в танке, мы тут создаём указатель, который будет бегать по области памяти с исходным списком
int count = 0;

while (current != NULL) {
    count++;
    current = current -> next;
} ;

printf("Total number of points: %d", count); 
```


По сути на этом всё, вы можете поиграться с этим примером, по классике он лежит в папке `example`. Вместе с командой для сборки.  


---

# Задание
---

## Общая информация

В этой лабораторной работе предусмотрено **два уровня сложности**:

1. **Базовый уровень** — позволяет получить **максимальный балл** за лабораторную.
2. **Продвинутый уровень** — даёт возможность получить **дополнительные баллы** (зависит от качества реализации и оценки ментора).

---

## Базовый уровень

### Цель

Создать **универсальные динамические структуры данных** `GenericList` (односвязный список) и `Vector` (динамический массив), которые могут работать с данными любого типа.

---

### Этап 1. Создание структуры односвязного списка

Реализуйте структуру `GenericList`, которая:

* Хранит данные в узлах (`Node`), где каждый узел содержит:
  * **Указатель на данные** (`void *data`) — для хранения значений любого типа
  * **Указатель на следующий узел** (`Node *next`) — для организации связи
* Хранит в самой структуре списка:
  * **Указатель на голову** (`Node *head`) — первый элемент списка
  * **Размер элемента** (`size_t elem_size`) — количество байт, необходимых для копирования одного элемента
* Использует **функции-компараторы** (указатели на функции типа `EqualsFunc`), чтобы можно было сравнивать элементы разных типов (int, float, структуры и т.д.) без переписывания кода.

**Файлы для реализации:**
* Интерфейс: `list/generic.h` (уже предоставлен)
* Реализация: `list/generic.c`
* Тесты: `list/tests.c`

---

### Этап 2. Реализация базовых операций для списка

Реализуйте следующие функции для работы со списком (согласно спецификации в `list/generic.h`):

* `createList()` — создание пустого списка
* `appendItem()` — добавление элемента в конец списка
* `findItem()` — поиск элемента с использованием функции-компаратора
* `popItem()` — удаление элемента по индексу с возвратом копии данных
* `listLength()` — получение количества элементов
* `freeList()` — освобождение всей памяти списка

**Важно:** Все операции должны выполнять **deep copy** данных (копирование содержимого, а не только указателя).

---

### Этап 3. Реализация динамического массива (вектора)

Создайте структуру `Vector`, аналогичную `std::vector` из C++:

* Хранит данные в **непрерывном блоке памяти** (`void *data`)
* Отслеживает:
  * **Размер** (`size_t size`) — текущее количество элементов
  * **Вместимость** (`size_t capacity`) — выделенная память в элементах
  * **Размер элемента** (`size_t elem_size`) — количество байт на элемент
* Поддерживает:
  * **Динамическое изменение размера** — автоматическое расширение при необходимости
  * **Быстрый доступ по индексу** — O(1)
  * **Работу с любыми типами данных** (через `void *` и `elem_size`)

**Файлы для реализации:**
* Интерфейс: `vector/generic.h` (уже предоставлен)
* Реализация: `vector/generic.c`
* Тесты: `vector/tests.c`

---

### Этап 4. Тестирование структур данных

Напишите комплексные тесты для обеих структур:

* **Базовые операции** — добавление, удаление, поиск
* **Работа с разными типами** — int, float, структуры
* **Граничные случаи** — пустые структуры, выход за границы
* **Управление памятью** — корректное освобождение памяти, отсутствие утечек
* **Нагрузочные тесты** — работа с большим количеством элементов (100k, 1M)

**Примеры тестов предоставлены в шаблонах.**

---

### Этап 5. Использование структур для решения задач

Используя ваши реализации `GenericList` и `Vector`, решите три задачи:

#### Задача 1. Поиск студента с максимальным баллом

* Используйте структуру данных:

  ```c
  typedef struct {
      char name[50];
      float avg;
  } Student;
  ```
* Создайте список (`GenericList`) или вектор (`Vector`) для хранения объектов типа `Student`.
* Добавьте несколько студентов с разными средними баллами.
* Найдите и выведите **имя студента с максимальным средним баллом (`avg`)**.

**Пример вывода:**
```
Студент с максимальным баллом: Иванов Иван (средний балл: 4.85)
```

---

#### Задача 2. Нахождение максимума в массиве

* Создайте вектор (`Vector`) с числовой последовательностью.
* Реализуйте функцию поиска **максимального значения**.
* Проверьте работу для типов:
  * `int`
  * `long int`
  * `float`

**Пример:**
```c
int numbers[] = {5, 2, 9, 1, 7};
Vector *vec = createVectorFromArray(numbers, sizeof(int), 5);
int max = findMax(vec);
printf("Максимум: %d\n", max); // Вывод: Максимум: 9
```

---

#### Задача 3. Удаление дубликатов

* Создайте список или вектор со строками (массив символов до 100 символов).
* Реализуйте функцию удаления **дубликатов**.

**Примеры:**

**Для списка (`GenericList`):**
```c
// Входные данные: ["banana", "mama", "banana", "papa", "mama"]
// Результат: ["banana", "mama", "papa"]
```

**Для вектора (`Vector`):**
```c
// Входные данные: [5, 2, 5, 1, 2, 9]
// Результат: [5, 2, 1, 9]
```

**Требования:**
* Сохранить порядок первого появления элемента
* Использовать функцию-компаратор для сравнения строк/чисел

---

## Продвинутый уровень

Если вы успешно справились с базовым уровнем, переходите к продвинутому.

### Задача: Векторизация текста (Bag-of-Words)

Используйте созданный вектор (`Vector`) для реализации **векторизации текста по модели "bag-of-words"**:

#### Описание задачи

**Bag-of-Words (мешок слов)** — это способ представления текста в виде вектора частот слов, игнорируя грамматику и порядок слов, но сохраняя информацию о количестве их появлений.

#### Шаги реализации

1. **Прочитайте текст** (из файла или строки)
   ```
   Пример: "мама мыла раму раму мыла мама"
   ```

2. **Выделите уникальные слова** и создайте "словарь"
   ```
   Словарь: ["мама", "мыла", "раму"]
   Индексы:    0       1       2
   ```

3. **Подсчитайте частоты** каждого слова
   ```
   "мама": 2 раза
   "мыла": 2 раза
   "раму": 2 раза
   ```

4. **Создайте вектор частот**
   ```
   Вектор: [2, 2, 2]
   ```

#### Структуры данных

Используйте комбинацию ваших структур:

```c
typedef struct {
    char word[100];  // Само слово
    int count;       // Частота появления
} WordFrequency;

// Вектор для хранения всех уникальных слов с частотами
Vector *vocabulary;

// Вектор для представления текста (индексы соответствуют словарю)
Vector *bow_vector;
```

#### Требования

* Игнорировать регистр (привести к lowercase)
* Удалить знаки пунктуации
* Использовать ваш `Vector` для хранения словаря и частот
* Вывести результат в читаемом виде

#### Пример работы программы

**Входной текст:**
```
The quick brown fox jumps over the lazy dog. The dog was not that lazy.
```

**Вывод программы:**
```
Вектор векторов (10 уникальных слов):
  0: the       -> 3
  1: quick     -> 1
  2: brown     -> 1
  3: fox       -> 1
  4: jumps     -> 1
  5: over      -> 1
  6: lazy      -> 2
  7: dog       -> 2
  8: was       -> 1
  9: not       -> 1
 10: that      -> 1

Bag-of-Words вектор: [3, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1]
```

**Подробнее о Bag-of-Words:**
* [Wikipedia: Bag-of-words model](https://en.wikipedia.org/wiki/Bag-of-words_model)

---

## Критерии оценки

### Базовый уровень (максимум 100%)

* Корректная реализация `GenericList` с всеми функциями — **30%**
* Корректная реализация `Vector` с всеми функциями — **35%**
* Полное покрытие тестами (включая граничные случаи) — **15%**
* Решение трёх задач (студент, максимум, дубликаты) — **20%**

### Продвинутый уровень (дополнительно до 40%)
* Базовая реализация Bag-of-Words — **+15%**
* Качество кода, документация, структура проекта — **+5%**
* Отсутствие утечек памяти (проверка через Valgrind) — **+20%**
---

## Полное ТЗ

Детальная спецификация всех функций находится в заголовочных файлах:
* `list/generic.h` — спецификация односвязного списка
* `vector/generic.h` — спецификация динамического массива

**Внимательно изучите комментарии в заголовочных файлах перед началом реализации!**
```

---
# СВОДКА

## Для компиляции базовых задач и запуска тестов:
```shell
gcc base_tasks.c base_tests.c list/generic.c vector/generic.c -o test_base_tasks -lm
```

```shell
./test_base_tasks
```

## Для компиляции продвинутых задач и запуска тестов:
```shell
gcc vector/generic.c extra_tasks.c extra_tests.c -o test_extra_tasks -lm
```

```shell
./test_extra_tasks
```

## Для запуска тестов ваших структур данных (на примере list)
```shell
cd list; gcc generic.c tests.c; ./a.out
```

