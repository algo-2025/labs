#ifndef VECTOR_GENERIC_H
#define VECTOR_GENERIC_H

/*
===============================================================================
ТЗ: Vector — универсальный динамический массив для хранения данных любого типа.
-------------------------------------------------------------------------------
Основная идея:
- Vector хранит элементы в непрерывном блоке памяти (void *data).
- Каждый элемент имеет фиксированный размер elem_size.
- При добавлении элемента массив автоматически расширяется при необходимости.
- Все операции выполняются через универсальные функции, не зависящие от типа.

Память:
- Выделяется единый блок памяти для всех элементов.
- При расширении выделяется новый блок, данные копируются, старый освобождается.
- Удаление вектора освобождает весь блок данных и структуру Vector.
===============================================================================
*/

#include <stdio.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdlib.h>
#include "../comparators.h"

#define MIN_SIZE 1

typedef struct
{
  void *data;       // Указатель на блок данных
  size_t elem_size; // Размер одного элемента в байтах
  size_t size;      // Текущее количество элементов
  size_t capacity;  // Вместимость (выделенная память в элементах)
} Vector;

/*
===============================================================================
Функция: createVector
Назначение: Создаёт пустой динамический массив для хранения элементов
            произвольного размера.

Аргументы:
- elem_size: размер одного элемента (в байтах), например sizeof(int).

Возвращает:
- Указатель на новую структуру Vector.
- NULL при ошибке выделения памяти.

Начальное состояние:
- size = 0 (массив пуст)
- capacity = MIN_SIZE (минимальная начальная вместимость)
===============================================================================
*/
Vector *createVector(size_t elem_size);

/*
===============================================================================
Функция: appendVectorItem
Назначение: Добавляет элемент в конец вектора (копирует переданные данные).

Аргументы:
- vector: указатель на вектор.
- el: указатель на данные, которые нужно скопировать в вектор.

Возвращает:
- 0 при успешном добавлении.
- Ненулевое значение при ошибке (например, невозможность расширить память).

Примечания:
- Функция делает копию данных по указателю (deep copy).
- Если size == capacity, автоматически расширяет вместимость (обычно в 2 раза).
- Добавление в конец выполняется за O(1) амортизированное время.

Ошибки:
- Возвращает код ошибки при невозможности выделить память для расширения.
===============================================================================
*/
int appendVectorItem(Vector *vector, void *el);

/*
===============================================================================
Функция: getVectorItem
Назначение: Возвращает указатель на элемент по индексу без его удаления.

Аргументы:
- vector: указатель на вектор.
- index: индекс элемента (начиная с 0).

Возвращает:
- Указатель на элемент внутри вектора (НЕ копию).
- NULL, если индекс вне диапазона или вектор пуст.

Предупреждение:
- Возвращаемый указатель валиден до следующей операции изменения вектора
  (добавление, удаление), так как при расширении память может быть
  перераспределена.
===============================================================================
*/
void *getVectorItem(Vector *vector, size_t index);

/*
===============================================================================
Функция: setVectorItem
Назначение: Заменяет значение элемента по индексу на новое.

Аргументы:
- vector: указатель на вектор.
- index: индекс элемента для замены (начиная с 0).
- value: указатель на новые данные для копирования.

Возвращает:
- 0 при успешной замене.
- Ненулевое значение при ошибке (индекс вне диапазона).

Примечания:
- Копирует elem_size байт из value в позицию index.
- НЕ изменяет размер вектора.
===============================================================================
*/
int setVectorItem(Vector *vector, size_t index, void *value);

/*
===============================================================================
Функция: popVectorItem
Назначение: Удаляет элемент по индексу и возвращает его копию.

Аргументы:
- vector: указатель на вектор.
- index: индекс удаляемого элемента (начиная с 0).

Возвращает:
- Указатель на копию данных (память выделена внутри функции — нужно освободить).
- NULL, если индекс вне диапазона или вектор пуст.

Поведение:
- Копирует данные элемента перед удалением.
- Сдвигает все элементы после удалённого влево на одну позицию.
- Уменьшает size на 1.

Ответственность вызывающей стороны:
- Необходимо освободить возвращённую память с помощью free().

Сложность:
- O(n), где n — количество элементов после удаляемого.
===============================================================================
*/
void *popVectorItem(Vector *vector, size_t index);

/*
===============================================================================
Функция: findVectorItem
Назначение: Находит индекс первого элемента, равного заданному значению.

Аргументы:
- vector: указатель на вектор.
- value: указатель на значение для поиска.
- cmp: функция для сравнения различных типов данных.

Возвращает:
- Индекс найденного элемента (начиная с 0).
- -1 (или отрицательное значение), если элемент не найден или вектор пуст.

Примечания:
- Использует побайтовое сравнение (memcmp) для поиска.
- Для пользовательских типов может потребоваться своя функция сравнения.

Сложность:
- O(n), требуется обход всего вектора в худшем случае.
===============================================================================
*/
long int findVectorItem(Vector *vector, void *value, EqualsFunc cmp);

/*
===============================================================================
Функция: vectorFree
Назначение: Полностью очищает вектор и освобождает всю выделенную память.

Аргументы:
- vector: указатель на вектор (может быть NULL).

Возвращает:
- 0 при успешном освобождении.
- Ненулевое значение при ошибке (например, vector == NULL).

Поведение:
- Освобождает блок данных (data).
- Освобождает саму структуру Vector.
- После вызова указатель на вектор становится невалидным.
===============================================================================
*/
int vectorFree(Vector *vector);

#endif